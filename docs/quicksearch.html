<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"adapters_lokijs-gibbon-adapter.js.html":{"id":"adapters_lokijs-gibbon-adapter.js.html","title":"Source: adapters/lokijs-gibbon-adapter.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Source: adapters/lokijs-gibbon-adapter.js 'use strict'; const util = require('util'); const _ = require('lodash'); const Loki = require('lokijs'); const GibbonAdapter = require('./gibbon-adapter'); const Gibbon = require('../gibbon'); const COLLECTION = { USER: 'user', GROUP: 'group', PERMISSION: 'permission' }; /** * @classdesc * Representing an adapter class for LokiJS * * @class * @augments GibbonAdapter * @param {object} [logger] - Logger instance */ function LokiJSGibbonAdapter(logger) { GibbonAdapter.call(this); Object.defineProperty(this, 'EVENT', { writable: true, enumerable: true, configurable: true, value: { ERROR: 'error', EVENT: 'event', WARNING: 'warning', CLOSE: 'close', LOADED: 'loaded' } }); Object.defineProperty(this, 'logger', { writable: true, enumerable: true, configurable: false, value: logger || console }); Object.defineProperty(this, 'dbCollection', { writable: true, enumerable: true, configurable: false, value: {} }); Object.defineProperty(this, 'db', { writable: true, enumerable: true, configurable: false, value: null }); } util.inherits(LokiJSGibbonAdapter, GibbonAdapter); /** * This gets a collection when not set, it will be created * @param {string} collectionName - document collection to be initialized * @private */ LokiJSGibbonAdapter.prototype._initializeCollection = function (collectionName) { this.dbCollection[collectionName] = this.db.getCollection(collectionName); if (!this.dbCollection[collectionName]) { this.dbCollection[collectionName] = this.db.addCollection(collectionName, { unique: ['name'], indices: ['name'] }); } // Receive events from lokiJS and pass them along: this.dbCollection[collectionName].on('warning', (warning) =&gt; { this.logger.warn(warning); this.emit(this.EVENT.WARNING, warning); }); this.dbCollection[collectionName].on('error', (errDoc) =&gt; { this.logger.error(errDoc); this.emit(this.EVENT.ERROR, errDoc); }); this.dbCollection[collectionName].on('close', () =&gt; { this.emit(this.EVENT.CLOSE); }); this.dbCollection[collectionName].on('loaded', (loaded) =&gt; { this.emit(this.EVENT.LOADED, loaded); }); }; /** * Generic Upsert method for user, group and permission collections * * @param {string} collection - Dynamic pointer to a collection * @param {object} criteria - In this adapter name is our unique reference for all collections * @param {object} data - Object to update or insert * @param {function} callback * @private */ LokiJSGibbonAdapter.prototype._upsertByName = function (collection, criteria, data, callback) { let dataFound = this.dbCollection[collection].findOne({name: criteria.name}); if (!dataFound) { dataFound = this.dbCollection[collection].insert(data); } else { dataFound = _.merge(dataFound, data); try { this.dbCollection[collection].update(dataFound); } catch (error) { return callback(error); } } return callback(null, dataFound); }; /** * Callback when initializing is done. * @callback _findByNameCallback * @param {Error} [error=null] - Error is omitted * @param {(object|null)} userObject - One instance of a fetched record * */ /** * Generic private method to dynamically query the collection and fetch data * @param {string} name - Collection name to query * @param {object} criteria - Criteria for finding data * @param {_findByNameCallback} callback * @private */ LokiJSGibbonAdapter.prototype._findByName = function (name, criteria, callback) { const found = this.dbCollection[name].findOne(criteria); callback(null, found); }; /** * Callback when initializing is done. * @callback initializeCallback */ /** * Initialize persistence storage itself and it's collections * @param {initializeCallback} callback - Callback when done */ LokiJSGibbonAdapter.prototype.initialize = function (callback) { const self = this; this.db = new Loki('lokijs.db', { autosave: false, autoload: true, verbose: true, autoloadCallback: loadHandler, }); function loadHandler() { // Initialize all collections self._initializeCollection(COLLECTION.USER); self._initializeCollection(COLLECTION.GROUP); self._initializeCollection(COLLECTION.PERMISSION); callback(); } }; /** * Tries to fetch a user * @param {object} criteria - LokiJS criteria * @param {function} callback */ LokiJSGibbonAdapter.prototype.findUser = function (criteria, callback) { this._findByName(COLLECTION.USER, criteria, callback); }; /** * Tries to fetch a group * @param {object} criteria - LokiJS criteria * @param {function} callback */ LokiJSGibbonAdapter.prototype.findGroup = function (criteria, callback) { this._findByName(COLLECTION.GROUP, criteria, callback); }; /** * Tries to find a permission * @param {object} criteria - LokiJS criteria * @param {function} callback */ LokiJSGibbonAdapter.prototype.findPermission = function (criteria, callback) { this._findByName(COLLECTION.PERMISSION, criteria, callback); }; /** * Add a user object to the user collection * @param {object} user - The user object * @param {function} callback */ LokiJSGibbonAdapter.prototype.addUser = function (user, callback) { this.dbCollection[COLLECTION.USER].insert(user); callback(null, user); }; /** * Add a group object to the group collection * @param {object} group - The group object * @param {function} callback */ LokiJSGibbonAdapter.prototype.addGroup = function (group, callback) { this.dbCollection[COLLECTION.GROUP].insert(group); callback(null, group); }; /** * Add a groups from array to the group collection * @param {Array} groups - The group object * @param {function} callback */ LokiJSGibbonAdapter.prototype.addGroups = function (groups, callback) { if (!(Array.isArray(groups))) { return callback(new TypeError('groups not an instance of array')); } const groupsAdded = []; for (let i = 0; i &lt; groups.length; i++) { const group = groups[i]; const groupAdded = this.dbCollection[COLLECTION.GROUP].insert(group); groupsAdded.push(groupAdded); } callback(null, groupsAdded); }; /** * Add a permission object to the permission collection * @param {object} permission - The permission object * @param {function} callback */ LokiJSGibbonAdapter.prototype.addPermission = function (permission, callback) { this.dbCollection[COLLECTION.PERMISSION].insert(permission); callback(null, permission); }; /** * Add a permission from array to the permission collection * @param {Array} permissions - The permission object * @param {function} callback */ LokiJSGibbonAdapter.prototype.addPermissions = function (permissions, callback) { if (!(Array.isArray(permissions))) { return callback(new TypeError('permissions not an instance of array')); } const permissionsAdded = []; for (let i = 0; i &lt; permissions.length; i++) { const permission = permissions[i]; const permissionAdded = this.dbCollection[COLLECTION.PERMISSION].insert(permission); permissionsAdded.push(permissionAdded); } callback(null, permissionsAdded); }; /** * Remove a user from the user collection * @param user * @param callback * @returns {*} */ LokiJSGibbonAdapter.prototype.removeUser = function (user, callback) { try { this.dbCollection[COLLECTION.USER].removeWhere({name: user.name}); } catch (error) { return callback(error); } callback(); }; /** * Remove a group from the group collection * @param group * @param callback * @returns {*} */ LokiJSGibbonAdapter.prototype.removeGroup = function (group, callback) { try { this.dbCollection[COLLECTION.GROUP].removeWhere({name: group.name}); } catch (error) { return callback(error); } callback(); }; /** * Remove a permission from the permission collection * @param permission * @param callback * @returns {*} */ LokiJSGibbonAdapter.prototype.removePermission = function (permission, callback) { try { this.dbCollection[COLLECTION.PERMISSION].removeWhere({name: permission.name}); } catch (error) { return callback(error); } callback(); }; /** * Insert or update a user (if not exists) * @override * @param {object} criteria - Where to find in case of update * @param {object} user - The user to update or insert * @param {function} callback */ LokiJSGibbonAdapter.prototype.upsertUser = function (criteria, user, callback) { this._upsertByName(COLLECTION.USER, criteria, user, callback); }; /** * Insert or update group (if not exists) * @override * @param {object} criteria - LokiJS criteria * @param {Gibbon} group * @param callback */ LokiJSGibbonAdapter.prototype.upsertGroup = function (criteria, group, callback) { this._upsertByName(COLLECTION.GROUP, criteria, group, callback); }; /** * Insert or update permissions (if not exists) * @override * @param {object} criteria - LokiJS criteria * @param permission * @param callback */ LokiJSGibbonAdapter.prototype.upsertPermission = function (criteria, permission, callback) { this._upsertByName(COLLECTION.PERMISSION, criteria, permission, callback); }; /** * Tries to fetch a collection of Hats representing groups * @override * @param {object} user - user object * @param callback */ LokiJSGibbonAdapter.prototype.findGroupsByUser = function (user, callback) { // Fetch user from lokijs const userFound = this.dbCollection[COLLECTION.USER].findOne({name: user.name}); if (!userFound) { return callback(new Error('user not found')); } // construct a new Gibbon instance from encoded groups const gibbon = Gibbon.fromString(userFound.groups); // Fetch lokijs groups from group collection const positions = gibbon.getPositionsArray(); const criteria = {'$loki': {'$in': positions}}; const groups = this.dbCollection[COLLECTION.GROUP].find(criteria); return callback(null, groups); }; /** * Given a user, it tries to fetch it's permissions * @param {object} user - Instance of a user object * @param {function} callback */ LokiJSGibbonAdapter.prototype.findPermissionsByUser = function (user, callback) { const self = this; let permissions = []; this.findGroupsByUser(user, (err, groups) =&gt; { if (err) { return callback(err); } let i = 0; for (i; i &lt; groups.length; i++) { const group = groups[i]; const permissionsFromGroup = group.permissions; const gibbon = Gibbon.fromString(permissionsFromGroup); const permissionBitPositions = gibbon.getPositionsArray(); permissions = permissions.concat(permissionBitPositions); permissions = _.uniq(permissions); } permissions = permissions.sort(function sortNumber(a, b) { return a - b; }); const criteria = {'$loki': {'$in': permissions}}; const permissionsFound = self.dbCollection[COLLECTION.PERMISSION].find(criteria); return callback(null, permissionsFound); }); }; /** * Validate a user against all given permissions &lt;br&gt; * When one of the given permissions is missing for the given user,&lt;br&gt; * given user is not valid. * * @param {object} user - User to validate * @param {Array&lt;Number&gt;} permissions - Array with unsigned integers with permissions (positions starting at 1) * @param {function} callback */ LokiJSGibbonAdapter.prototype.validateUserWithAllPermissions = function (user, permissions, callback) { let valid = false; this.findPermissionsByUser(user, (error, permissionsFound) =&gt; { if (error) { return callback(error, valid); } if (!(Array.isArray(permissions)) || permissions.length &lt;= 0) { return callback(null, valid); } const permissionsAttachedToUser = _.map(permissionsFound, '$loki'); const missingPermissions = _.difference(permissions, permissionsAttachedToUser); valid = !(Array.isArray(missingPermissions) &amp;&amp; missingPermissions.length &gt; 0); callback(null, valid); }); }; /** * Validate a user against any given permissions &lt;br&gt; * When one of the given permissions is found for the given user,&lt;br&gt; * the outcome is valid. * * @param {object} user - User to validate * @param {Array&lt;Number&gt;} permissions - Array with unsigned integers with permissions (positions starting at 1) * @param {function} callback */ LokiJSGibbonAdapter.prototype.validateUserWithAnyPermissions = function (user, permissions, callback) { let valid = false; this.findPermissionsByUser(user, (error, permissionsFound) =&gt; { if (error) { return callback(error, valid); } if (!(Array.isArray(permissions)) || permissions.length &lt;= 0) { return callback(null, valid); } const permissionsAttachedToUser = _.map(permissionsFound, '$loki'); const overlappingPermissions = _.intersection(permissions, permissionsAttachedToUser); valid = (Array.isArray(overlappingPermissions) &amp;&amp; overlappingPermissions.length &gt; 0); callback(null, valid); }); }; module.exports = LokiJSGibbonAdapter; × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"gibbon-processor.js.html":{"id":"gibbon-processor.js.html","title":"Source: gibbon-processor.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Source: gibbon-processor.js 'use strict'; /** * @classdesc * Just a class to carry byte position and bit position around * * @param {Number} byteNo - unsigned integer value (0..n) * @param {Number} bitPos - unsigned integer value (0..n) * @class */ function BitByte(byteNo, bitPos) { this.byteNo = byteNo; this.bitPos = bitPos; } /** * This is the Gibbon Processor which does all the bit masking, nothing special ;) * @namespace */ const GibbonProcessor = {}; /** * Transforms a position (1..n) to byte index and inner bit position * * @example * * getByteNoAndBitPos(1); // returns { byteNo: 0, bitPos: 0} * * getByteNoAndBitPos(256); // returns { byteNo: 31, bitPos: 7} * * @memberOf GibbonProcessor * @param {Number} position - Unsigned integer value (1..n) * @returns {BitByte} - A new a BitByte instance * @throws {Error} when position is &lt;= 0 */ GibbonProcessor.getByteNoAndBitPos = function (position) { if (position &lt;= 0) { throw new Error('Illegal position'); } const index = position - 1; return new BitByte(Math.trunc(index / 8), index % 8); }; /** * Check if bit is set true on index * * @example * * isTrue(13, 2); // returns true * * // 0000 1101 data * // * // 0000 0011 data (after data &gt;&gt;= index) * // 0000 0001 * // ---------- AND * // 0000 0001 === 0000 0001 (true) * // * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {boolean} */ GibbonProcessor.isTrue = function (data, index) { /* eslint-disable */ data &gt;&gt;= index; return (data &amp; 0x1) === 0x1; /* eslint-enable */ }; /** * Check if bit is set false on index * * @example * * isFalse(13, 2); // returns false * * // 0000 1101 data * // * // 0000 0011 data (after data &gt;&gt;= index) * // 0000 0001 * // ---------- AND * // 0000 0001 === 0000 0000 (false) * // * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {boolean} */ GibbonProcessor.isFalse = function (data, index) { /* eslint-disable */ data &gt;&gt;= index; return (data &amp; 0x1) === 0x0; /* eslint-enable */ }; /** * Set bit true on data from index * * @example * * setBit(0, 1); // returns 1 * * // 0000 0000 data * // 0000 0001 mask * // ---------------- OR * // 0000 0001 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {Number} */ GibbonProcessor.setBit = function (data, index) { /* eslint-disable */ let mask = 1 &lt;&lt; index; return data | mask; /* eslint-enable */ }; /** * Set bit false on data from index * * @example * * clearBit(1, 0); // returns 0(dec) * * // 0000 0001 mask * // * // 0000 0001 data * // 1111 1110 ~mask * // ---------------- AND * // 0000 0000 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {Number} */ GibbonProcessor.clearBit = function (data, index) { /* eslint-disable */ let mask = 1 &lt;&lt; index; return data &amp; ~mask; /* eslint-enable */ }; /** * Change bit according to given value on data from index * * @example * * changeBit(1, 0, false); // returns 0(dec) * * // 0000 0001 data * // 1111 1110 mask ~ * // ---------------- AND * // 0000 0000 x1 * // * // 0000 0000 state * // 0000 0001 mask * // ---------------- AND * // 0000 0000 x2 * // * // 0000 0000 (x1) * // 0000 0000 (x2) * // ---------------- OR * // 0000 0000 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @param {*} value - truthy | falsy * @returns {Number} */ GibbonProcessor.changeBit = function (data, index, value) { /* eslint-disable */ let mask = 1 &lt;&lt; index; // value relies on true = 1 and false = 0 let state = value ? 0x1 : 0x0; return (data &amp; ~mask) | (-state &amp; mask); /* eslint-enable */ }; /** * Toggle (inverse) bit value on data from index * * @example * * toggleBit(1, 0); // Returns 0(dec) * * // 0000 0001 mask * // 0000 0001 data * // --------------- XOR * // 0000 0000 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {Number} */ GibbonProcessor.toggleBit = function (data, index) { /* eslint-disable */ let mask = 1 &lt;&lt; index; return data ^ mask; /* eslint-enable */ }; module.exports.GibbonProcessor = GibbonProcessor; module.exports.BitByte = BitByte; × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"gibbon.js.html":{"id":"gibbon.js.html","title":"Source: gibbon.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Source: gibbon.js 'use strict'; const GibbonProcessor = require('./gibbon-processor').GibbonProcessor; /** * A Gibbon * @class * @param {ArrayBuffer} arrayBuffer - allocate this Gibbon with some working memory * @throws {TypeError} if arrayBuffer is not an instance of ArrayBuffer */ function Gibbon(arrayBuffer) { if (!(arrayBuffer instanceof ArrayBuffer)) { throw new TypeError('argument not an instance of ArrayBuffer'); } this.arrayBuffer = arrayBuffer; this.dataView = new DataView(this.arrayBuffer); } /** * Compare two gibbon instances on data contents * * @param {Gibbon} gibbon - instance of &lt;b&gt;a&lt;/b&gt; Gibbon * @returns {boolean} if instance (or contents) are the same * @throws {TypeError} if gibbon is not an instance of Gibbon */ Gibbon.prototype.compare = function (gibbon) { let same = false; if (!(gibbon instanceof Gibbon)) { throw new TypeError('gibbon is not an instance of Gibbon'); } const arrayBuffer = gibbon.arrayBuffer; const thisArrayBuffer = this.arrayBuffer; if (thisArrayBuffer === arrayBuffer) { same = true; } else { const thisDataView = this.dataView; const dataView = gibbon.dataView; const byteLength = Math.max(thisArrayBuffer.byteLength, arrayBuffer.byteLength); let result = true; for (let i = 0; i &lt; byteLength &amp;&amp; result; i++) { const value1 = (i &lt; thisDataView.byteLength) ? thisDataView.getUint8(i) : 0x0; const value2 = (i &lt; dataView.byteLength) ? dataView.getUint8(i) : 0x0; if (value1 !== value2) { result = false; } } same = result; } return same; }; /** * This method analyzes every bit value in this gibbon and creates the corresponding &lt;br&gt; * position array where bits are logical true. * * @example * * * // Initialize a Gibbon with ArrayBuffer (size = 2 bytes) * const ab = new ArrayBuffer(2); * const gibbon = new Gibbon(ab); * * // Pre set some bit positions * gibbon.setPosition(1) * .setPosition(2) * .setPosition(3) * .setPosition(4) * .setPosition(5) * .setPosition(6) * .setPosition(7) * .setPosition(8) * .setPosition(10); * * gibbon.getPositionsArray(); // returns: [1, 2, 3, 4, 5, 6, 7, 8, 10] * * * @returns {Array} Which contains bit positions from this gibbon, which are logical set to true */ Gibbon.prototype.getPositionsArray = function () { const dataView = this.dataView; const byteLength = this.arrayBuffer.byteLength; const positions = []; for (let byteNo = 0; byteNo &lt; byteLength; byteNo++) { const value = dataView.getUint8(byteNo); for (let bitPos = 0; bitPos &lt; 8; bitPos++) { const posValue = GibbonProcessor.isTrue(value, bitPos); if (posValue) { positions.push(byteNo * 8 + bitPos + 1); } } } return positions; }; /** * Set bit: true according to integer position in the Gibbon &lt;br&gt; * &lt;i&gt;Note: Starting from 1&lt;/i&gt; * @throws {Error} Position can't exceed data view bounds. * @param {Number} position - unsigned integer value * @returns {Gibbon} - For chaining purposes */ Gibbon.prototype.setPosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); const dataViewBounds = this.dataView.byteLength; if (bitBytePosition.byteNo &lt; dataViewBounds) { let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.setBit(byte, bitBytePosition.bitPos); this.dataView.setUint8(bitBytePosition.byteNo, byte); } else { // Because we can't exceed the amount of allocated bytes, // Please ensure position ends within the allocated memory throw new Error('Illegal position'); } return this; }; /** * Set bit: false according to integer position * Note: Starting from 1 * @param {Number} position - unsigned integer value * @returns {Gibbon} */ Gibbon.prototype.clearPosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.clearBit(byte, bitBytePosition.bitPos); this.dataView.setUint8(bitBytePosition.byteNo, byte); return this; }; /** * Toggle bit value true =&gt; false, false =&gt; true * @example * * const gibbon = new Gibbon(ArrayBuffer(2)); * gibbon.changePosition(1, true); * * gibbon.isPosition(1); // true * * @param {Number} position - unsigned integer value * @returns {Gibbon} */ Gibbon.prototype.togglePosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.toggleBit(byte, bitBytePosition.bitPos); this.dataView.setUint8(bitBytePosition.byteNo, byte); return this; }; /** * Set value for a bit on position * * @example * * const gibbon = new Gibbon(ArrayBuffer(2)); * gibbon.changePosition(1, true); * * gibbon.isPosition(1); // returns true * * * @param {Number} position - unsigned integer value * @param {boolean} [on] - Optional set true or false (default : false) * @returns {Gibbon} - Return itself for chaining purposes */ Gibbon.prototype.changePosition = function (position, on = false) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.changeBit(byte, bitBytePosition.bitPos, on); this.dataView.setUint8(bitBytePosition.byteNo, byte); return this; }; /** * Checks if a value is true or false on a specific position * * * @example * * const gibbon = new Gibbon(ArrayBuffer(2)); * gibbon.setPosition(1); * * gibbon.isPosition(1); // returns true * * @param {Number} position - unsigned integer value * @returns {boolean} if membership is set */ Gibbon.prototype.isPosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); const result = GibbonProcessor.isTrue(byte, bitBytePosition.bitPos); return result; }; /** * Compares all given positions * - A positive position means this position should be set truthy * - A negative position means this position should be set falsy * * When wants to check on bit positions outside the memory bounds (dataViewBounds), &lt;br&gt; * method wil return early with falsy result * * * @example * * // Set 2 bit positions to logical '1' * const gibbon = new Gibbon(new ArrayBuffer(2)); * gibbon.setPosition(1).setPosition(2); * * gibbon.hasAllFromPositions([1, 2]); // true * * @example * * // Set 2 bit positions to logical '1' then the first bit position back to '0' * const gibbon = new Gibbon(new ArrayBuffer(2)); * gibbon.setPosition(1).setPosition(2),togglePosition(1); * * gibbon.hasAllFromPositions([-1, 2]); // true * * @param {Array&lt;Number&gt;} positionArray - containing signed integer values (representing bit positions) * @return {boolean} true when all positions correspondent to the given indexes * @throws {TypeError} if positionArray is not an instance of array * */ Gibbon.prototype.hasAllFromPositions = function (positionArray = []) { const self = this; const dataViewBounds = self.dataView.byteLength; if (!(Array.isArray(positionArray))) { throw new TypeError('positionArray not an instance of Array'); } // Shallow copy let positions = positionArray.slice(); // Remove duplicate values: positions = positions.filter(function (value, index, self) { return self.indexOf(value) === index; }); // Check bits on position if they are truthy (positive position) or falsy (negative position) let hasAllFromPositions = true; // Exit early when one of the positions is not logic true. for (let i = 0; i &lt; positions.length &amp;&amp; hasAllFromPositions; i++) { const position = positions[i]; const positionAbs = Math.abs(position); const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(positionAbs); // Check if position is not out of bound of the data view: if (bitBytePosition.byteNo &lt; dataViewBounds) { const byte = self.dataView.getUint8(bitBytePosition.byteNo); if (position &gt;= 0) { hasAllFromPositions = GibbonProcessor.isTrue(byte, bitBytePosition.bitPos); } else { hasAllFromPositions = GibbonProcessor.isFalse(byte, bitBytePosition.bitPos); } } else { // Position is outside the bounds of the DataView, skipping the rest... hasAllFromPositions = false; } } return hasAllFromPositions; }; /** * Able to manipulate bits according to an array of signed integers * * @example * * // Set 2 bit positions to logical '1' * const gibbon = Gibbon.create(2); * gibbon.setAllFromPositions([1, 2]); * gibbon.hasAllFromPositions([1, 2]); // returns true * * @example * * // Set 1 bit positions to logical '1' and the second to '0' * const gibbon = Gibbon.create(2); * gibbon.setAllFromPositions([1, -2]); * gibbon.hasAllFromPositions([1]); // returns true * * @param {Array&lt;Number&gt;} positionArray - Array with integer values starting from 1. * @returns {Gibbon} - For chaining purposes * @throws {TypeError} if positionArray is not an instance of array */ Gibbon.prototype.setAllFromPositions = function (positionArray = []) { const self = this; const dataViewBounds = self.dataView.byteLength; if (!(Array.isArray(positionArray))) { throw new TypeError('positionArray not an instance of Array'); } // Shallow copy let positions = positionArray.slice(); // Remove duplicate values: positions = positions.filter(function (value, index, self) { return self.indexOf(value) === index; }); for (let i = 0; i &lt; positions.length; i++) { const position = positions[i]; const positionAbs = Math.abs(position); const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(positionAbs); // Check if position is not out of bound of the data view: if (bitBytePosition.byteNo &lt; dataViewBounds) { let byte = self.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.changeBit(byte, bitBytePosition.bitPos, (position &gt;= 0)); self.dataView.setUint8(bitBytePosition.byteNo, byte); } } return self; }; /** * Convert the whole ArrayBuffer to a string * (Hint: Could be used to store a gibbon in persistent storage as a encoded string) * * @returns {string} - Encoded string * @override */ Gibbon.prototype.toString = function () { return String.fromCharCode.apply(null, new Uint16Array(this.arrayBuffer)); }; /** * Class method to create a new Gibbon from a string * (Could be used to retrieve from persistent storage) * @param {string} str - Representing a new Gibbon instance * @returns {Gibbon} - new instance of a Gibbon * @throws {TypeError} if given argument is not an instance of string */ Gibbon.fromString = function (str = '') { if (typeof str !== 'string') { throw new TypeError('argument not a string'); } const arrayBuffer = new ArrayBuffer(str.length * 2); // 2 bytes for each char const typedArray = new Uint16Array(arrayBuffer); for (let i = 0, strLen = str.length; i &lt; strLen; i++) { typedArray[i] = str.charCodeAt(i); } return new Gibbon(arrayBuffer); }; /** * Creates a new empty Gibbon from a given byte size * @param {Number} byteSize - Allocate this Gibbon with a unsigned integer value (size in bytes) * @returns {Gibbon} - new instance of a Gibbon */ Gibbon.create = function (byteSize) { const arrayBuffer = new ArrayBuffer(byteSize); return new Gibbon(arrayBuffer); }; module.exports = Gibbon; × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"adapters_gibbon-adapter.js.html":{"id":"adapters_gibbon-adapter.js.html","title":"Source: adapters/gibbon-adapter.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Source: adapters/gibbon-adapter.js 'use strict'; const util = require('util'); const EventEmitter = require('events').EventEmitter; const INHERITANCE_ERROR = 'Abstract method, override please.'; /** * @classdesc * * This class should be inherited and acts as contract (Interface) * * @extends EventEmitter * @class * @abstract */ function GibbonAdapter() { EventEmitter.call(this); } util.inherits(GibbonAdapter, EventEmitter); /** * Initialize adapter * * @abstract */ GibbonAdapter.prototype.initialize = function () { throw new Error(INHERITANCE_ERROR); }; GibbonAdapter.prototype.addUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add user group * * @abstract */ GibbonAdapter.prototype.addGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add array of user groups * * @abstract */ GibbonAdapter.prototype.addGroups = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add group permission * @abstract */ GibbonAdapter.prototype.addPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Remove a user * @abstract */ GibbonAdapter.prototype.removeUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Remove a group * @abstract */ GibbonAdapter.prototype.removeGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Remove a permission * @abstract */ GibbonAdapter.prototype.removePermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Update or insert user (if not exists) * @abstract */ GibbonAdapter.prototype.upsertUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Update or insert group (if not exists) * @abstract */ GibbonAdapter.prototype.upsertGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Update or insert permission (if not exists) * @abstract */ GibbonAdapter.prototype.upsertPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find user groups * @abstract */ GibbonAdapter.prototype.findGroupsByUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find user permissions * @abstract */ GibbonAdapter.prototype.findPermissionsByUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find user * @abstract */ GibbonAdapter.prototype.findUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find group * @abstract */ GibbonAdapter.prototype.findGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find permission * @abstract */ GibbonAdapter.prototype.findPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Validate a user against e.g. given permissions &lt;br&gt; * All permissions given, need to correspond with the permissions owned by this user. * * @abstract */ GibbonAdapter.prototype.validateUserWithAllPermissions = function () { throw new Error(INHERITANCE_ERROR); }; /** * Validate a user against e.g. given permissions &lt;br&gt; * When one of the given permissions are found at this user, user is valid. * @abstract */ GibbonAdapter.prototype.validateUserWithAnyPermissions = function () { throw new Error(INHERITANCE_ERROR); }; module.exports = GibbonAdapter; × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"gibbons.js.html":{"id":"gibbons.js.html","title":"Source: gibbons.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Source: gibbons.js 'use strict'; const GibbonAdapter = require('./adapters/gibbon-adapter'); /** * @class * * This is the Gibbons class&lt;br&gt; * It's the entry point for group- and permission handling * * @param {GibbonAdapter} gibbonAdapter - An instance of GibbonAdapter is required. * @throws {TypeError} When given argument is not an instance of GibbonAdapter * */ function Gibbons(gibbonAdapter) { if (!(gibbonAdapter instanceof GibbonAdapter)) { throw new TypeError('adapter processor not of expected type'); } const adapter = gibbonAdapter; Object.defineProperty(this, 'adapter', { get: function () { return adapter; } }); Object.defineProperty(this, 'config', { writable: true, enumerable: true, configurable: true }); } /** * Initializes Gibbons&lt;br&gt; * (it initializes the given adapter) * * @param {function} callback */ Gibbons.prototype.initialize = function (callback) { this.adapter.initialize(callback); }; /** * Finds a user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - User to find * @param {function} callback */ Gibbons.prototype.findUser = function (criteria, callback) { this.adapter.findUser(criteria, callback); }; /** * Finds a group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Group to find * @param {function} callback */ Gibbons.prototype.findGroup = function (criteria, callback) { this.adapter.findGroup(criteria, callback); }; /** * Finds a permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Permission to find * @param {function} callback */ Gibbons.prototype.findPermission = function (criteria, callback) { this.adapter.findPermission(criteria, callback); }; /** * Adds a user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User to add * @param {function} callback */ Gibbons.prototype.addUser = function (user, callback) { this.adapter.addUser(user, callback); }; /** * Add a group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} group - Group to add * @param {function} callback */ Gibbons.prototype.addGroup = function (group, callback) { this.adapter.addGroup(group, callback); }; /** * Adds an array of groups&lt;br&gt; * (Is delegated to a given adapter) * * @param {Array&lt;object&gt;} groups - Collection of groups to add * @param {function} callback */ Gibbons.prototype.addGroups = function (groups, callback) { this.adapter.addGroups(groups, callback); }; /** * Add a permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} permission - Permission to add * @param {function} callback */ Gibbons.prototype.addPermission = function (permission, callback) { this.adapter.addPermission(permission, callback); }; /** * Adds an array of permissions&lt;br&gt; * (Is delegated to a given adapter) * * @param {Array&lt;object&gt;} permissions - Collection of permissions to add * @param {function} callback */ Gibbons.prototype.addPermissions = function (permissions, callback) { this.adapter.addPermissions(permissions, callback); }; /** * Removes a user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User criteria for removal of a certain user * @param {function} callback */ Gibbons.prototype.removeUser = function (user, callback) { this.adapter.removeUser(user, callback); }; /** * Removes a group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} group - Group criteria for removal of a certain group * @param {function} callback */ Gibbons.prototype.removeGroup = function (group, callback) { this.adapter.removeGroup(group, callback); }; /** * Removes a permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} permission - Permission criteria for removal of a certain permission * @param {function} callback */ Gibbons.prototype.removePermission = function (permission, callback) { this.adapter.removePermission(permission, callback); }; /** * Updates an existing user, and if not found inserts the user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - User criteria to update when found * @param {object} user - Data to merge with existing user, or to insert * @param {function} callback */ Gibbons.prototype.upsertUser = function (criteria, user, callback) { this.adapter.upsertUser(criteria, user, callback); }; /** * Updates an existing group, and if not found inserts the group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Group criteria to update when found * @param {object} group - Data to merge with existing group, or to insert * @param {function} callback */ Gibbons.prototype.upsertGroup = function (criteria, group, callback) { this.adapter.upsertGroup(criteria, group, callback); }; /** * Updates an existing permission, and if not found inserts the permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Permission criteria to update when found * @param {object} permission - Data to merge with existing permission, or to insert * @param {function} callback */ Gibbons.prototype.upsertPermission = function (criteria, permission, callback) { this.adapter.upsertPermission(criteria, permission, callback); }; /** * Finds a group collection attached to this certain user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User criteria to find the corresponding groups * @param {function} callback */ Gibbons.prototype.findGroupsByUser = function (user, callback) { this.adapter.findGroupsByUser(user, callback); }; /** * Finds a permission collection attached to this certain user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User criteria to find the corresponding permissions * @param {function} callback */ Gibbons.prototype.findPermissionsByUser = function (user, callback) { this.adapter.findPermissionsByUser(user, callback); }; /** * Validates given user against given array of permission positions. * &lt;b&gt;All&lt;/b&gt; given permissions need to be found at this given user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User as criteria to validate * @param {Array&lt;Number&gt;} permissions * @param {function} callback */ Gibbons.prototype.validateUserWithAllPermissions = function (user, permissions, callback) { this.adapter.validateUserWithAllPermissions(user, permissions, callback); }; /** * Validates given user against given array of permission positions. * &lt;b&gt;If any&lt;/b&gt; given permission is found attached to this given user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User to validate permissions against * @param {Array&lt;Number&gt;} permissions - Permission collection of integers * @param {function} callback */ Gibbons.prototype.validateUserWithAnyPermissions = function (user, permissions, callback) { this.adapter.validateUserWithAnyPermissions(user, permissions, callback); }; module.exports = Gibbons; × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Global Type Definitions _findByNameCallback( [error], userObject) Callback when initializing is done. Parameters: Name Type Argument Default Description error Error &lt;optional&gt; null Error is omitted userObject object | null One instance of a fetched record Source: adapters/lokijs-gibbon-adapter.js, line 122 initializeCallback() Callback when initializing is done. Source: adapters/lokijs-gibbon-adapter.js, line 142 × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Classes Classes BitByte Gibbon GibbonAdapter Gibbons LokiJSGibbonAdapter Namespaces GibbonProcessor × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Namespaces Classes BitByte Gibbon GibbonAdapter Gibbons LokiJSGibbonAdapter Namespaces GibbonProcessor × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Tutorials Classes BitByte Gibbon GibbonAdapter Gibbons LokiJSGibbonAdapter Namespaces GibbonProcessor × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Gibbons&quot;Leaping from branch to branch gibbons decide which one to take in a split second&quot; Gibbons is a Node.js module which helps in managing user groups and user permissions with bitwise efficiency. In applying ArrayBuffers and bitwise operations it tries to use minimal resources. API Documentation and tutorialSee: Gibbons Docs How do I get set up?npm install gibbons DetailsPrerequisites to contribute Clone this repository, and check out the develop branch Ensure Node Version Manager is installed and operational nvm install npm install -g gulp LintingFor this project ESLint is applied. Execute: gulp lint Currently the linter conforms to defaults from: eslint-plugin-node and some minor tweaks (see: .eslint.js). Unit testsEvery path should be covered and can be checked after the unit test is executed, according to a coverage report. Execute: gulp test In the end, a brief version of the coverage report is shown. For the more extensive one, see: test/coverage/lcov-report/index.html. API DocumentationA Gulp plugin: gulp-jsdoc3 is applied to generate the API documentation. It's expected to write extensive comments in the code itself when contributing. Every time code is updated, we need to ensure the documentation is in sync with the code. Execute: gulp docs The result is generated at: docs/index.html Contribution guidelines When adding new features / code, creating corresponding unit tests are mandatory Code review will be done by means of pull requests to the develop branch, preferably with the following pull request template: h1. I ensured: * [ ] I've updated the unit tests and covered enough parts of the code (`gulp lint` and `gulp test`) * [ ] I've updated the API documentation within the code and generated a fresh export (`gulp docs`)Meta data Maintainer: Ivo Cazemier Bitbucket or Github API documentation and tutorial (License: MIT, See the LICENSE file) × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"BitByte.html":{"id":"BitByte.html","title":"Class: BitByte","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Class: BitByte BitByte Just a class to carry byte position and bit position around new BitByte(byteNo, bitPos) Parameters: Name Type Description byteNo Number unsigned integer value (0..n) bitPos Number unsigned integer value (0..n) Source: gibbon-processor.js, line 11 × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"Gibbon.html":{"id":"Gibbon.html","title":"Class: Gibbon","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Class: Gibbon Gibbon new Gibbon(arrayBuffer) A Gibbon Parameters: Name Type Description arrayBuffer ArrayBuffer allocate this Gibbon with some working memory Source: gibbon.js, line 11 Throws: if arrayBuffer is not an instance of ArrayBuffer Type TypeError Methods &lt;static&gt; create(byteSize) Creates a new empty Gibbon from a given byte size Parameters: Name Type Description byteSize Number Allocate this Gibbon with a unsigned integer value (size in bytes) Source: gibbon.js, line 355 Returns: new instance of a Gibbon Type Gibbon &lt;static&gt; fromString(str) Class method to create a new Gibbon from a string (Could be used to retrieve from persistent storage) Parameters: Name Type Description str string Representing a new Gibbon instance Source: gibbon.js, line 337 Throws: if given argument is not an instance of string Type TypeError Returns: new instance of a Gibbon Type Gibbon changePosition(position [, on]) Set value for a bit on position Parameters: Name Type Argument Description position Number unsigned integer value on boolean &lt;optional&gt; Optional set true or false (default : false) Source: gibbon.js, line 168 Returns: Return itself for chaining purposes Type Gibbon Example const gibbon = new Gibbon(ArrayBuffer(2)); gibbon.changePosition(1, true); gibbon.isPosition(1); // returns true clearPosition(position) Set bit: false according to integer position Note: Starting from 1 Parameters: Name Type Description position Number unsigned integer value Source: gibbon.js, line 125 Returns: Type Gibbon compare(gibbon) Compare two gibbon instances on data contents Parameters: Name Type Description gibbon Gibbon instance of a Gibbon Source: gibbon.js, line 27 Throws: if gibbon is not an instance of Gibbon Type TypeError Returns: if instance (or contents) are the same Type boolean getPositionsArray() This method analyzes every bit value in this gibbon and creates the corresponding position array where bits are logical true. Source: gibbon.js, line 81 Returns: Which contains bit positions from this gibbon, which are logical set to true Type Array Example // Initialize a Gibbon with ArrayBuffer (size = 2 bytes) const ab = new ArrayBuffer(2); const gibbon = new Gibbon(ab); // Pre set some bit positions gibbon.setPosition(1) .setPosition(2) .setPosition(3) .setPosition(4) .setPosition(5) .setPosition(6) .setPosition(7) .setPosition(8) .setPosition(10); gibbon.getPositionsArray(); // returns: [1, 2, 3, 4, 5, 6, 7, 8, 10] hasAllFromPositions(positionArray) Compares all given positions A positive position means this position should be set truthy A negative position means this position should be set falsy When wants to check on bit positions outside the memory bounds (dataViewBounds), method wil return early with falsy result Parameters: Name Type Description positionArray Array.&lt;Number&gt; containing signed integer values (representing bit positions) Source: gibbon.js, line 227 Throws: if positionArray is not an instance of array Type TypeError Returns: true when all positions correspondent to the given indexes Type boolean Examples // Set 2 bit positions to logical '1' const gibbon = new Gibbon(new ArrayBuffer(2)); gibbon.setPosition(1).setPosition(2); gibbon.hasAllFromPositions([1, 2]); // true // Set 2 bit positions to logical '1' then the first bit position back to '0' const gibbon = new Gibbon(new ArrayBuffer(2)); gibbon.setPosition(1).setPosition(2),togglePosition(1); gibbon.hasAllFromPositions([-1, 2]); // true isPosition(position) Checks if a value is true or false on a specific position Parameters: Name Type Description position Number unsigned integer value Source: gibbon.js, line 190 Returns: if membership is set Type boolean Example const gibbon = new Gibbon(ArrayBuffer(2)); gibbon.setPosition(1); gibbon.isPosition(1); // returns true setAllFromPositions(positionArray) Able to manipulate bits according to an array of signed integers Parameters: Name Type Description positionArray Array.&lt;Number&gt; Array with integer values starting from 1. Source: gibbon.js, line 289 Throws: if positionArray is not an instance of array Type TypeError Returns: For chaining purposes Type Gibbon Examples // Set 2 bit positions to logical '1' const gibbon = Gibbon.create(2); gibbon.setAllFromPositions([1, 2]); gibbon.hasAllFromPositions([1, 2]); // returns true // Set 1 bit positions to logical '1' and the second to '0' const gibbon = Gibbon.create(2); gibbon.setAllFromPositions([1, -2]); gibbon.hasAllFromPositions([1]); // returns true setPosition(position) Set bit: true according to integer position in the Gibbon Note: Starting from 1 Parameters: Name Type Description position Number unsigned integer value Source: gibbon.js, line 104 Throws: Position can't exceed data view bounds. Type Error Returns: For chaining purposes Type Gibbon togglePosition(position) Toggle bit value true =&gt; false, false =&gt; true Parameters: Name Type Description position Number unsigned integer value Source: gibbon.js, line 145 Returns: Type Gibbon Example const gibbon = new Gibbon(ArrayBuffer(2)); gibbon.changePosition(1, true); gibbon.isPosition(1); // true toString() Convert the whole ArrayBuffer to a string (Hint: Could be used to store a gibbon in persistent storage as a encoded string) Source: gibbon.js, line 326 Returns: Encoded string Type string × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"GibbonAdapter.html":{"id":"GibbonAdapter.html","title":"Class: GibbonAdapter","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Class: GibbonAdapter GibbonAdapter This class should be inherited and acts as contract (Interface) &lt;abstract&gt; new GibbonAdapter() Source: adapters/gibbon-adapter.js, line 16 Extends EventEmitter Methods &lt;abstract&gt; addGroup() Add user group Source: adapters/gibbon-adapter.js, line 42 &lt;abstract&gt; addGroups() Add array of user groups Source: adapters/gibbon-adapter.js, line 51 &lt;abstract&gt; addPermission() Add group permission Source: adapters/gibbon-adapter.js, line 59 &lt;abstract&gt; findGroup() Find group Source: adapters/gibbon-adapter.js, line 141 &lt;abstract&gt; findGroupsByUser() Find user groups Source: adapters/gibbon-adapter.js, line 116 &lt;abstract&gt; findPermission() Find permission Source: adapters/gibbon-adapter.js, line 149 &lt;abstract&gt; findPermissionsByUser() Find user permissions Source: adapters/gibbon-adapter.js, line 124 &lt;abstract&gt; findUser() Find user Source: adapters/gibbon-adapter.js, line 133 &lt;abstract&gt; initialize() Initialize adapter Source: adapters/gibbon-adapter.js, line 28 &lt;abstract&gt; removeGroup() Remove a group Source: adapters/gibbon-adapter.js, line 75 &lt;abstract&gt; removePermission() Remove a permission Source: adapters/gibbon-adapter.js, line 83 &lt;abstract&gt; removeUser() Remove a user Source: adapters/gibbon-adapter.js, line 67 &lt;abstract&gt; upsertGroup() Update or insert group (if not exists) Source: adapters/gibbon-adapter.js, line 100 &lt;abstract&gt; upsertPermission() Update or insert permission (if not exists) Source: adapters/gibbon-adapter.js, line 108 &lt;abstract&gt; upsertUser() Update or insert user (if not exists) Source: adapters/gibbon-adapter.js, line 92 &lt;abstract&gt; validateUserWithAllPermissions() Validate a user against e.g. given permissions All permissions given, need to correspond with the permissions owned by this user. Source: adapters/gibbon-adapter.js, line 160 &lt;abstract&gt; validateUserWithAnyPermissions() Validate a user against e.g. given permissions When one of the given permissions are found at this user, user is valid. Source: adapters/gibbon-adapter.js, line 169 × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"GibbonProcessor.html":{"id":"GibbonProcessor.html","title":"Namespace: GibbonProcessor","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Namespace: GibbonProcessor GibbonProcessor This is the Gibbon Processor which does all the bit masking, nothing special ;) Source: gibbon-processor.js, line 20 Methods &lt;static&gt; changeBit(data, index, value) Change bit according to given value on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) value * truthy | falsy Source: gibbon-processor.js, line 177 Returns: Type Number Example changeBit(1, 0, false); // returns 0(dec) // 0000 0001 data // 1111 1110 mask ~ // ---------------- AND // 0000 0000 x1 // // 0000 0000 state // 0000 0001 mask // ---------------- AND // 0000 0000 x2 // // 0000 0000 (x1) // 0000 0000 (x2) // ---------------- OR // 0000 0000 result &lt;static&gt; clearBit(data, index) Set bit false on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: gibbon-processor.js, line 142 Returns: Type Number Example clearBit(1, 0); // returns 0(dec) // 0000 0001 mask // // 0000 0001 data // 1111 1110 ~mask // ---------------- AND // 0000 0000 result &lt;static&gt; getByteNoAndBitPos(position) Transforms a position (1..n) to byte index and inner bit position Parameters: Name Type Description position Number Unsigned integer value (1..n) Source: gibbon-processor.js, line 37 Throws: when position is &lt;= 0 Type Error Returns: A new a BitByte instance Type BitByte Example getByteNoAndBitPos(1); // returns { byteNo: 0, bitPos: 0} getByteNoAndBitPos(256); // returns { byteNo: 31, bitPos: 7} &lt;static&gt; isFalse(data, index) Check if bit is set false on index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: gibbon-processor.js, line 92 Returns: Type boolean Example isFalse(13, 2); // returns false // 0000 1101 data // // 0000 0011 data (after data &gt;&gt;= index) // 0000 0001 // ---------- AND // 0000 0001 === 0000 0000 (false) // &lt;static&gt; isTrue(data, index) Check if bit is set true on index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: gibbon-processor.js, line 65 Returns: Type boolean Example isTrue(13, 2); // returns true // 0000 1101 data // // 0000 0011 data (after data &gt;&gt;= index) // 0000 0001 // ---------- AND // 0000 0001 === 0000 0001 (true) // &lt;static&gt; setBit(data, index) Set bit true on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: gibbon-processor.js, line 116 Returns: Type Number Example setBit(0, 1); // returns 1 // 0000 0000 data // 0000 0001 mask // ---------------- OR // 0000 0001 result &lt;static&gt; toggleBit(data, index) Toggle (inverse) bit value on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: gibbon-processor.js, line 203 Returns: Type Number Example toggleBit(1, 0); // Returns 0(dec) // 0000 0001 mask // 0000 0001 data // --------------- XOR // 0000 0000 result × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"Gibbons.html":{"id":"Gibbons.html","title":"Class: Gibbons","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Class: Gibbons Gibbons This is the Gibbons class It's the entry point for group- and permission handling new Gibbons(gibbonAdapter) Parameters: Name Type Description gibbonAdapter GibbonAdapter An instance of GibbonAdapter is required. Source: gibbons.js, line 14 Throws: When given argument is not an instance of GibbonAdapter Type TypeError Methods addGroup(group, callback) Add a group (Is delegated to a given adapter) Parameters: Name Type Description group object Group to add callback function Source: gibbons.js, line 96 addGroups(groups, callback) Adds an array of groups (Is delegated to a given adapter) Parameters: Name Type Description groups Array.&lt;object&gt; Collection of groups to add callback function Source: gibbons.js, line 107 addPermission(permission, callback) Add a permission (Is delegated to a given adapter) Parameters: Name Type Description permission object Permission to add callback function Source: gibbons.js, line 118 addPermissions(permissions, callback) Adds an array of permissions (Is delegated to a given adapter) Parameters: Name Type Description permissions Array.&lt;object&gt; Collection of permissions to add callback function Source: gibbons.js, line 129 addUser(user, callback) Adds a user (Is delegated to a given adapter) Parameters: Name Type Description user object User to add callback function Source: gibbons.js, line 85 findGroup(criteria, callback) Finds a group (Is delegated to a given adapter) Parameters: Name Type Description criteria object Group to find callback function Source: gibbons.js, line 62 findGroupsByUser(user, callback) Finds a group collection attached to this certain user (Is delegated to a given adapter) Parameters: Name Type Description user object User criteria to find the corresponding groups callback function Source: gibbons.js, line 210 findPermission(criteria, callback) Finds a permission (Is delegated to a given adapter) Parameters: Name Type Description criteria object Permission to find callback function Source: gibbons.js, line 74 findPermissionsByUser(user, callback) Finds a permission collection attached to this certain user (Is delegated to a given adapter) Parameters: Name Type Description user object User criteria to find the corresponding permissions callback function Source: gibbons.js, line 221 findUser(criteria, callback) Finds a user (Is delegated to a given adapter) Parameters: Name Type Description criteria object User to find callback function Source: gibbons.js, line 51 initialize(callback) Initializes Gibbons (it initializes the given adapter) Parameters: Name Type Description callback function Source: gibbons.js, line 40 removeGroup(group, callback) Removes a group (Is delegated to a given adapter) Parameters: Name Type Description group object Group criteria for removal of a certain group callback function Source: gibbons.js, line 151 removePermission(permission, callback) Removes a permission (Is delegated to a given adapter) Parameters: Name Type Description permission object Permission criteria for removal of a certain permission callback function Source: gibbons.js, line 162 removeUser(user, callback) Removes a user (Is delegated to a given adapter) Parameters: Name Type Description user object User criteria for removal of a certain user callback function Source: gibbons.js, line 140 upsertGroup(criteria, group, callback) Updates an existing group, and if not found inserts the group (Is delegated to a given adapter) Parameters: Name Type Description criteria object Group criteria to update when found group object Data to merge with existing group, or to insert callback function Source: gibbons.js, line 187 upsertPermission(criteria, permission, callback) Updates an existing permission, and if not found inserts the permission (Is delegated to a given adapter) Parameters: Name Type Description criteria object Permission criteria to update when found permission object Data to merge with existing permission, or to insert callback function Source: gibbons.js, line 199 upsertUser(criteria, user, callback) Updates an existing user, and if not found inserts the user (Is delegated to a given adapter) Parameters: Name Type Description criteria object User criteria to update when found user object Data to merge with existing user, or to insert callback function Source: gibbons.js, line 174 validateUserWithAllPermissions(user, permissions, callback) Validates given user against given array of permission positions. All given permissions need to be found at this given user (Is delegated to a given adapter) Parameters: Name Type Description user object User as criteria to validate permissions Array.&lt;Number&gt; callback function Source: gibbons.js, line 234 validateUserWithAnyPermissions(user, permissions, callback) Validates given user against given array of permission positions. If any given permission is found attached to this given user (Is delegated to a given adapter) Parameters: Name Type Description user object User to validate permissions against permissions Array.&lt;Number&gt; Permission collection of integers callback function Source: gibbons.js, line 247 × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"LokiJSGibbonAdapter.html":{"id":"LokiJSGibbonAdapter.html","title":"Class: LokiJSGibbonAdapter","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Class: LokiJSGibbonAdapter LokiJSGibbonAdapter Representing an adapter class for LokiJS new LokiJSGibbonAdapter( [logger]) Parameters: Name Type Argument Description logger object &lt;optional&gt; Logger instance Source: adapters/lokijs-gibbon-adapter.js, line 23 Extends GibbonAdapter Methods &lt;private&gt; _findByName(name, criteria, callback) Generic private method to dynamically query the collection and fetch data Parameters: Name Type Description name string Collection name to query criteria object Criteria for finding data callback _findByNameCallback Source: adapters/lokijs-gibbon-adapter.js, line 137 &lt;private&gt; _initializeCollection(collectionName) This gets a collection when not set, it will be created Parameters: Name Type Description collectionName string document collection to be initialized Source: adapters/lokijs-gibbon-adapter.js, line 69 &lt;private&gt; _upsertByName(collection, criteria, data, callback) Generic Upsert method for user, group and permission collections Parameters: Name Type Description collection string Dynamic pointer to a collection criteria object In this adapter name is our unique reference for all collections data object Object to update or insert callback function Source: adapters/lokijs-gibbon-adapter.js, line 107 addGroup(group, callback) Add a group object to the group collection Parameters: Name Type Description group object The group object callback function Overrides: GibbonAdapter#addGroup Source: adapters/lokijs-gibbon-adapter.js, line 216 addGroups(groups, callback) Add a groups from array to the group collection Parameters: Name Type Description groups Array The group object callback function Overrides: GibbonAdapter#addGroups Source: adapters/lokijs-gibbon-adapter.js, line 226 addPermission(permission, callback) Add a permission object to the permission collection Parameters: Name Type Description permission object The permission object callback function Overrides: GibbonAdapter#addPermission Source: adapters/lokijs-gibbon-adapter.js, line 245 addPermissions(permissions, callback) Add a permission from array to the permission collection Parameters: Name Type Description permissions Array The permission object callback function Source: adapters/lokijs-gibbon-adapter.js, line 255 addUser(user, callback) Add a user object to the user collection Parameters: Name Type Description user object The user object callback function Source: adapters/lokijs-gibbon-adapter.js, line 206 findGroup(criteria, callback) Tries to fetch a group Parameters: Name Type Description criteria object LokiJS criteria callback function Overrides: GibbonAdapter#findGroup Source: adapters/lokijs-gibbon-adapter.js, line 187 findGroupsByUser() Find user groups Inherited From: GibbonAdapter#findGroupsByUser Overrides: GibbonAdapter#findGroupsByUser Source: adapters/gibbon-adapter.js, line 116 findPermission(criteria, callback) Tries to find a permission Parameters: Name Type Description criteria object LokiJS criteria callback function Overrides: GibbonAdapter#findPermission Source: adapters/lokijs-gibbon-adapter.js, line 196 findPermissionsByUser(user, callback) Given a user, it tries to fetch it's permissions Parameters: Name Type Description user object Instance of a user object callback function Overrides: GibbonAdapter#findPermissionsByUser Source: adapters/lokijs-gibbon-adapter.js, line 377 findUser(criteria, callback) Tries to fetch a user Parameters: Name Type Description criteria object LokiJS criteria callback function Overrides: GibbonAdapter#findUser Source: adapters/lokijs-gibbon-adapter.js, line 178 initialize(callback) Initialize persistence storage itself and it's collections Parameters: Name Type Description callback initializeCallback Callback when done Overrides: GibbonAdapter#initialize Source: adapters/lokijs-gibbon-adapter.js, line 151 removeGroup(group, callback) Remove a group from the group collection Parameters: Name Type Description group callback Overrides: GibbonAdapter#removeGroup Source: adapters/lokijs-gibbon-adapter.js, line 292 Returns: Type * removePermission(permission, callback) Remove a permission from the permission collection Parameters: Name Type Description permission callback Overrides: GibbonAdapter#removePermission Source: adapters/lokijs-gibbon-adapter.js, line 307 Returns: Type * removeUser(user, callback) Remove a user from the user collection Parameters: Name Type Description user callback Overrides: GibbonAdapter#removeUser Source: adapters/lokijs-gibbon-adapter.js, line 277 Returns: Type * upsertGroup() Update or insert group (if not exists) Inherited From: GibbonAdapter#upsertGroup Overrides: GibbonAdapter#upsertGroup Source: adapters/gibbon-adapter.js, line 100 upsertPermission() Update or insert permission (if not exists) Inherited From: GibbonAdapter#upsertPermission Overrides: GibbonAdapter#upsertPermission Source: adapters/gibbon-adapter.js, line 108 upsertUser() Update or insert user (if not exists) Inherited From: GibbonAdapter#upsertUser Overrides: GibbonAdapter#upsertUser Source: adapters/gibbon-adapter.js, line 92 validateUserWithAllPermissions(user, permissions, callback) Validate a user against all given permissions When one of the given permissions is missing for the given user, given user is not valid. Parameters: Name Type Description user object User to validate permissions Array.&lt;Number&gt; Array with unsigned integers with permissions (positions starting at 1) callback function Overrides: GibbonAdapter#validateUserWithAllPermissions Source: adapters/lokijs-gibbon-adapter.js, line 417 validateUserWithAnyPermissions(user, permissions, callback) Validate a user against any given permissions When one of the given permissions is found for the given user, the outcome is valid. Parameters: Name Type Description user object User to validate permissions Array.&lt;Number&gt; Array with unsigned integers with permissions (positions starting at 1) callback function Overrides: GibbonAdapter#validateUserWithAnyPermissions Source: adapters/lokijs-gibbon-adapter.js, line 443 × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "},"tutorial-Tutorial.html":{"id":"tutorial-Tutorial.html","title":"Tutorial: Tutorial","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global Global Tutorial Coming soon! × Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-01-26T22:28:17+01:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
